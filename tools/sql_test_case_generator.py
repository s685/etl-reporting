#!/usr/bin/env python3
"""
SQL Test Case Generator from Excel Mapping

Reads an Excel file with table/column mappings and generates SQL Server test cases.
- One test case per column
- SUM aggregation for columns containing "amt"
- COUNT + GROUP BY for other columns
"""

import argparse
import logging
import sys
from pathlib import Path
from typing import List, Tuple
import openpyxl

logging.basicConfig(
    format='%(asctime)s - %(levelname)s - %(message)s',
    level=logging.INFO
)


class TestCaseGenerator:
    """Generate SQL test cases from Excel mapping."""

    def __init__(self, database: str | None = None, schema: str | None = None):
        self.database = database
        self.schema = schema

    def _get_full_table_name(self, table_name: str) -> str:
        """Get fully qualified table name."""
        # If table already has dots (qualified), use as-is
        if '.' in table_name:
            return table_name
        
        # Otherwise, prepend database and schema if provided
        if self.database and self.schema:
            return f"{self.database}.{self.schema}.{table_name}"
        elif self.schema:
            return f"{self.schema}.{table_name}"
        
        return table_name

    def _generate_check_name(self, table_name: str, column_name: str, is_amt: bool) -> str:
        """Generate check name from table and column."""
        # Extract short table name (last part after dots)
        table_short = table_name.split('.')[-1].upper()
        column_upper = column_name.upper()
        
        suffix = "SUM" if is_amt else "CNT"
        # Truncate if too long, keep readable
        check_name = f"{table_short}_{column_upper}_{suffix}"
        
        return check_name

    def _is_amount_column(self, column_name: str) -> bool:
        """Check if column is an amount column."""
        return 'amt' in column_name.lower()

    def _generate_sum_test(
        self, 
        table_name: str, 
        column_name: str, 
        filter_column: str,
        check_name: str
    ) -> str:
        """Generate SUM test for amount columns."""
        sql = f"""-- Test: {table_name}.{column_name} (SUM aggregation)
SELECT 
    '{check_name}' AS check_name,
    SUM({column_name}) AS total_amt
FROM {table_name}
WHERE {filter_column} >= DATEADD(DAY, -7, CAST(GETDATE() AS DATE))
  AND {filter_column} < CAST(GETDATE() AS DATE);
"""
        return sql

    def _generate_count_test(
        self,
        table_name: str,
        column_name: str,
        filter_column: str,
        check_name: str
    ) -> str:
        """Generate COUNT + GROUP BY test for non-amount columns."""
        sql = f"""-- Test: {table_name}.{column_name} (GROUP BY + COUNT)
SELECT 
    '{check_name}' AS check_name,
    {column_name},
    COUNT(*) AS row_cnt
FROM {table_name}
WHERE {filter_column} >= DATEADD(DAY, -7, CAST(GETDATE() AS DATE))
  AND {filter_column} < CAST(GETDATE() AS DATE)
GROUP BY {column_name};
"""
        return sql

    def parse_excel(
        self, 
        excel_path: str, 
        sheet_name: str = "Test_Cases"
    ) -> List[Tuple[str, str, str | None, str | None]]:
        """
        Parse Excel mapping file.
        
        Returns: List of (table_name, column_name, primary_key, filter_column)
        """
        wb = openpyxl.load_workbook(excel_path, data_only=True)
        
        if sheet_name not in wb.sheetnames:
            logging.error(f"Sheet '{sheet_name}' not found. Available: {wb.sheetnames}")
            sys.exit(1)
        
        ws = wb[sheet_name]
        
        mapping = []
        # Skip header row (row 1)
        for row in ws.iter_rows(min_row=2, values_only=True):
            if not row[0]:  # Skip empty rows
                continue
            
            table_name = row[0]
            column_name = row[1] if len(row) > 1 else None
            primary_key = row[2] if len(row) > 2 else None
            filter_column = row[3] if len(row) > 3 else None
            
            if not table_name or not column_name:
                logging.warning(f"Skipping row with missing table or column: {row}")
                continue
            
            mapping.append((table_name, column_name, primary_key, filter_column))
        
        wb.close()
        return mapping

    def generate_test_cases(
        self,
        mapping: List[Tuple[str, str, str | None, str | None]]
    ) -> str:
        """Generate SQL test cases from mapping."""
        sql_output = []
        
        # Header
        sql_output.append("-- =====================================================================")
        sql_output.append("-- AUTO-GENERATED SQL TEST CASES")
        sql_output.append("-- Generated by: sql_test_case_generator.py")
        sql_output.append("-- =====================================================================")
        sql_output.append("")
        
        for table_name, column_list, primary_key, filter_column in mapping:
            # Skip if filter_column is missing
            if not filter_column:
                logging.warning(f"Skipping {table_name}: missing filter_column")
                continue
            
            # Get fully qualified table name
            full_table = self._get_full_table_name(table_name)
            
            # Split comma-separated columns
            columns = [col.strip() for col in column_list.split(',') if col.strip()]
            
            for column in columns:
                is_amt = self._is_amount_column(column)
                check_name = self._generate_check_name(table_name, column, is_amt)
                
                if is_amt:
                    test_sql = self._generate_sum_test(
                        full_table, column, filter_column, check_name
                    )
                else:
                    test_sql = self._generate_count_test(
                        full_table, column, filter_column, check_name
                    )
                
                sql_output.append(test_sql)
        
        return '\n'.join(sql_output)


def parse_args():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="Generate SQL test cases from Excel mapping"
    )
    parser.add_argument(
        "excel_path",
        help="Path to Excel mapping file"
    )
    parser.add_argument(
        "--output",
        help="Output SQL file path (default: stdout)",
        default=None
    )
    parser.add_argument(
        "--database",
        help="Database name to prepend to table names",
        default=None
    )
    parser.add_argument(
        "--schema",
        help="Schema name to prepend to table names",
        default=None
    )
    parser.add_argument(
        "--sheet",
        help="Excel sheet name (default: Test_Cases)",
        default="Test_Cases"
    )
    
    return parser.parse_args()


def main():
    """Main execution."""
    args = parse_args()
    
    # Validate Excel file exists
    if not Path(args.excel_path).is_file():
        logging.error(f"Excel file not found: {args.excel_path}")
        sys.exit(1)
    
    # Create generator
    generator = TestCaseGenerator(
        database=args.database,
        schema=args.schema
    )
    
    # Parse Excel
    logging.info(f"Parsing Excel file: {args.excel_path}")
    mapping = generator.parse_excel(args.excel_path, args.sheet)
    logging.info(f"Found {len(mapping)} table mappings")
    
    # Count total columns
    total_columns = sum(len([c.strip() for c in cols.split(',') if c.strip()]) 
                       for _, cols, _, _ in mapping)
    logging.info(f"Generating {total_columns} test cases")
    
    # Generate SQL
    sql_output = generator.generate_test_cases(mapping)
    
    # Write output
    if args.output:
        output_path = Path(args.output)
        output_path.write_text(sql_output, encoding='utf-8')
        logging.info(f"SQL test cases written to: {args.output}")
    else:
        print(sql_output)


if __name__ == "__main__":
    main()
